#include <bits/stdc++.h>
using namespace std;

#ifndef DIVIDE_METHOD
#define DIVIDE_METHOD 1
#endif
class big_int{
    private:
        string P;
        static void A(string&s){int p=s.find_first_not_of(48);p==(int)string::npos?s="0":s.erase(0,p);}
        static void B(string&a,string&b){A(a);A(b);}
        static bool C(const string&s){return!s.empty()&&s[0]==45;}
        static string D(const string& s){if(s.empty()||s=="-0")return"0";bool n=s[0]==45;string t=n?s.substr(1):s;A(t);return t=="0"?"0":n?"-"+t:t;}
        static int E(string a,string b){B(a,b);if(a.size()>b.size())return 1;if(a.size()<b.size())return -1;if(a==b)return 0;return a>b?1:-1;}
        static string F(string a,string b){string r;int i=a.size()-1,j=b.size()-1,c=0;while(i+1||j+1||c){c+=(i+1?a[i--]-48:0)+(j+1?b[j--]-48:0);r+=c%10+48;c/=10;}reverse(r.begin(),r.end());return r;}
        static string G(const string&a,const string&b){bool n=C(a),m=C(b);if(n&&m)return G(b.substr(1),a.substr(1));if(n^m)return n?"-"+F(a.substr(1),b):F(a,b.substr(1));int c=E(a,b);if(!c)return"0";const string&x=c>0?a:b,&y=c>0?b:a;int i=x.size()-1,j=y.size()-1,k=0;string r;while(i>=0){int v=x[i--]-48-(j>=0?y[j--]-48:0)-k;k=v<0;if(v<0)v+=10;r+=v+48;}while(r.size()>1&&r.back()==48)r.pop_back();reverse(r.begin(),r.end());return c>0?r:"-"+r;}
        static string H(string a,string b){bool x=C(a),y=C(b);string A=x?a.substr(1):a,B=y?b.substr(1):b;if(!(x^y))return x?"-"+F(A,B):F(A,B);int c=E(A,B);return c?((c>0?(x?"-":"")+G(A,B):(y?"-":"")+G(B,A))):"0";}
        static void I(vector<complex<double>>&a){int n=a.size(),l=31-__builtin_clz(n);static vector<complex<long double>>r(2,1);static vector<complex<double>>t(2,1);for(static int k=2;k<n;k*=2){r.resize(n);t.resize(n);auto x=polar(1.0L,acos(-1.0L)/k);for(int i=k;i<k+k;i++)t[i]=r[i]=i&1?r[i/2]*x:r[i/2];}vector<int>v(n);for(int i=0;i<n;i++)v[i]=(v[i/2]|(i&1)<<l)/2;for(int i=0;i<n;i++)if(i<v[i])swap(a[i],a[v[i]]);for(int k=1;k<n;k*=2)for(int i=0;i<n;i+=2*k)for(int j=0;j<k;j++){auto x=(double*)&t[j+k],y=(double*)&a[i+j+k];complex<double>z(x[0]*y[0]-x[1]*y[1],x[0]*y[1]+x[1]*y[0]);a[i+j+k]=a[i+j]-z;a[i+j]+=z;}}
        template<typename T>
        static vector<T>J(const vector<T>&a, const vector<T>&b){if(a.empty()||b.empty())return {};vector<T>res((int)a.size()+(int)b.size()-1);int L=32-__builtin_clz((int)res.size()), n=1<<L;vector<complex<double>>in(n), out(n);copy(a.begin(),a.end(),begin(in));for(int i=0;i<(int)b.size();i++)in[i].imag(b[i]);I(in);for(complex<double>&x:in)x*=x;for(int i=0;i<n;i++)out[i]=in[-i&(n-1)]-conj(in[i]);I(out);for(int i=0;i<(int)res.size();i++)res[i]=static_cast<T>(imag(out[i])/(4*n)+((is_integral_v<T>)?(imag(out[i])>0?0.5:-0.5):0));return res;}
        static string K(const string&a,const string&b){int B=1000,D=3;bool n=C(a),m=C(b);string x=n?a.substr(1):a,y=m?b.substr(1):b;if(x=="0"||y=="0")return"0";vector<int>p,q;for(int i=x.size();i>0;i-=D){int t=0,l=max(0,i-D);for(int j=l;j<i;j++)t=t*10+x[j]-48;p.push_back(t);}for(int i=y.size();i>0;i-=D){int t=0,l=max(0,i-D);for(int j=l;j<i;j++)t=t*10+y[j]-48;q.push_back(t);}vector<long long>r=J(vector<long long>(p.begin(),p.end()),vector<long long>(q.begin(),q.end()));long long c=0;for(size_t i=0;i<r.size();i++){long long t=r[i]+c;r[i]=t%B;c=t/B;}while(c){r.push_back(c%B);c/=B;}while(r.size()>1&&r.back()==0)r.pop_back();string s=to_string(r.back());for(int i=r.size()-2;i>=0;i--){string t=to_string((int)r[i]);while(t.size()<D)t='0'+t;s+=t;}return n^m?"-"+s:s;}
        static string L(const string&a,const string&b,string q){return G(a,K(b,q));}
        static string M(const string& a,const string& b){string c=a,d=b;bool e=C(c),f=C(d);if(e)c=c.substr(1);if(f)d=d.substr(1);if(c=="0")return"0";if(d=="0")throw out_of_range("dividebyzeroerror");string g="",h="0";for(char k:c){h+=k;A(h);int i=0;while(1){string j=G(h,d);if(C(j))break;h=j;i++;}g+=i+48;}A(g);if(e^f)g="-"+g;if(DIVIDE_METHOD){if(C(L(a,b,g))){if(e^f)g=G(g,"1");else g=H(g,"1");}}else{if(L(a,b,g)=="0")return g=="-0"?"0":g;if(e^f)g=G(g,"1");}return g=="-0"?"0":g;}
        static string N(string a,string b){return G(a,K(b,M(a,b)));}
    public:
        big_int():P("0"){}
        big_int(const string&s):P(D(s)){}
        big_int(const char*s):P(D(string(s))){}
        big_int(int x){P=to_string(x);}big_int(long long x){P=to_string(x);}
        string str()const{return P;}
        friend istream&operator>>(istream& i,big_int& n){string s;i>>s;n=big_int(s);return i;}
        friend ostream&operator<<(ostream&o,const big_int&n){o<<n.str();return o;}
        bool operator<(const big_int& n)const{bool a=C(P),b=C(n.P);if(a&&!b)return 1;if(!a&&b)return 0;string x=a?P.substr(1):P,y=b?n.P.substr(1):n.P;B(x,y);if(x.size()!=y.size())return (x.size()<y.size())^a;return x!=y?(x<y)^a:0;}
        bool operator>(const big_int& n)const{return n<*this;};
        bool operator==(const big_int& n)const{return P==n.P;}
        bool operator<=(const big_int& n)const{return P<n.P||P==n.P;}
        bool operator>=(const big_int& n)const{return P>n.P||P==n.P;}
        bool operator!=(const big_int& n)const{return!(P==n.P);}
        big_int operator+(const big_int& n)const{return big_int(H(this->P,n.P));}
        big_int operator-(const big_int& n)const{return big_int(G(this->P,n.P));}
        big_int operator*(const big_int& n)const{return big_int(K(this->P,n.P));}
        big_int operator/(const big_int& n)const{return big_int(M(this->P,n.P));}
        big_int operator%(const big_int& n)const{return big_int(N(this->P,n.P));}
        big_int operator+=(const big_int& n){this->P=D(H(this->P,n.P));return*this;}
        big_int operator-=(const big_int& n){this->P=D(G(this->P,n.P));return*this;}
        big_int operator*=(const big_int& n){this->P=D(K(this->P,n.P));return*this;}
        big_int operator/=(const big_int& n){this->P=D(M(this->P,n.P));return*this;}
        big_int&operator++(){*this+=big_int("1");return*this;}
        big_int operator++(int){big_int t=*this;++(*this);return t;}
        big_int&operator--(){*this-=big_int("1");return*this;}
        big_int operator--(int){big_int t=*this;--(*this);return t;}
};
int main(){
    return 0;
}

/*

#include <bits/stdc++.h>
using namespace std;
#define DIVIDE_METHOD 1
class big_int{private:string P;static void A(string&s){int p=s.find_first_not_of(48);p==(int)string::npos?s="0":s.erase(0,p);}static void B(string&a,string&b){A(a);A(b);}static bool C(const string&s){return!s.empty()&&s[0]==45;}static string D(const string& s){if(s.empty()||s=="-0")return"0";bool n=s[0]==45;string t=n?s.substr(1):s;A(t);return t=="0"?"0":n?"-"+t:t;}static int E(string a,string b){B(a,b);if(a.size()>b.size())return 1;if(a.size()<b.size())return -1;if(a==b)return 0;return a>b?1:-1;}static string F(string a,string b){string r;int i=a.size()-1,j=b.size()-1,c=0;while(i+1||j+1||c){c+=(i+1?a[i--]-48:0)+(j+1?b[j--]-48:0);r+=c%10+48;c/=10;}reverse(r.begin(),r.end());return r;}static string G(const string&a,const string&b){bool n=C(a),m=C(b);if(n&&m)return G(b.substr(1),a.substr(1));if(n^m)return n?"-"+F(a.substr(1),b):F(a,b.substr(1));int c=E(a,b);if(!c)return"0";const string&x=c>0?a:b,&y=c>0?b:a;int i=x.size()-1,j=y.size()-1,k=0;string r;while(i>=0){int v=x[i--]-48-(j>=0?y[j--]-48:0)-k;k=v<0;if(v<0)v+=10;r+=v+48;}while(r.size()>1&&r.back()==48)r.pop_back();reverse(r.begin(),r.end());return c>0?r:"-"+r;}static string H(string a,string b){bool x=C(a),y=C(b);string A=x?a.substr(1):a,B=y?b.substr(1):b;if(!(x^y))return x?"-"+F(A,B):F(A,B);int c=E(A,B);return c?((c>0?(x?"-":"")+G(A,B):(y?"-":"")+G(B,A))):"0";}static void I(vector<complex<double>>&a){int n=a.size(),l=31-__builtin_clz(n);static vector<complex<long double>>r(2,1);static vector<complex<double>>t(2,1);for(static int k=2;k<n;k*=2){r.resize(n);t.resize(n);auto x=polar(1.0L,acos(-1.0L)/k);for(int i=k;i<k+k;i++)t[i]=r[i]=i&1?r[i/2]*x:r[i/2];}vector<int>v(n);for(int i=0;i<n;i++)v[i]=(v[i/2]|(i&1)<<l)/2;for(int i=0;i<n;i++)if(i<v[i])swap(a[i],a[v[i]]);for(int k=1;k<n;k*=2)for(int i=0;i<n;i+=2*k)for(int j=0;j<k;j++){auto x=(double*)&t[j+k],y=(double*)&a[i+j+k];complex<double>z(x[0]*y[0]-x[1]*y[1],x[0]*y[1]+x[1]*y[0]);a[i+j+k]=a[i+j]-z;a[i+j]+=z;}}template<typename T>static vector<T>J(const vector<T>&a, const vector<T>&b){if(a.empty()||b.empty())return {};vector<T>res((int)a.size()+(int)b.size()-1);int L=32-__builtin_clz((int)res.size()), n=1<<L;vector<complex<double>>in(n), out(n);copy(a.begin(),a.end(),begin(in));for(int i=0;i<(int)b.size();i++)in[i].imag(b[i]);I(in);for(complex<double>&x:in)x*=x;for(int i=0;i<n;i++)out[i]=in[-i&(n-1)]-conj(in[i]);I(out);for(int i=0;i<(int)res.size();i++)res[i]=static_cast<T>(imag(out[i])/(4*n)+((is_integral_v<T>)?(imag(out[i])>0?0.5:-0.5):0));return res;}static string K(const string&a,const string&b){int B=1000,D=3;bool n=C(a),m=C(b);string x=n?a.substr(1):a,y=m?b.substr(1):b;if(x=="0"||y=="0")return"0";vector<int>p,q;for(int i=x.size();i>0;i-=D){int t=0,l=max(0,i-D);for(int j=l;j<i;j++)t=t*10+x[j]-48;p.push_back(t);}for(int i=y.size();i>0;i-=D){int t=0,l=max(0,i-D);for(int j=l;j<i;j++)t=t*10+y[j]-48;q.push_back(t);}vector<long long>r=J(vector<long long>(p.begin(),p.end()),vector<long long>(q.begin(),q.end()));long long c=0;for(size_t i=0;i<r.size();i++){long long t=r[i]+c;r[i]=t%B;c=t/B;}while(c){r.push_back(c%B);c/=B;}while(r.size()>1&&r.back()==0)r.pop_back();string s=to_string(r.back());for(int i=r.size()-2;i>=0;i--){string t=to_string((int)r[i]);while(t.size()<D)t='0'+t;s+=t;}return n^m?"-"+s:s;}static string L(const string&a,const string&b,string q){return G(a,K(b,q));}static string M(const string& a,const string& b){string c=a,d=b;bool e=C(c),f=C(d);if(e)c=c.substr(1);if(f)d=d.substr(1);if(c=="0")return"0";if(d=="0")throw out_of_range("dividebyzeroerror");string g="",h="0";for(char k:c){h+=k;A(h);int i=0;while(1){string j=G(h,d);if(C(j))break;h=j;i++;}g+=i+48;}A(g);if(e^f)g="-"+g;if(DIVIDE_METHOD){if(C(L(a,b,g))){if(e^f)g=G(g,"1");else g=H(g,"1");}}else{if(L(a,b,g)=="0")return g=="-0"?"0":g;if(e^f)g=G(g,"1");}return g=="-0"?"0":g;}static string N(string a,string b){return G(a,K(b,M(a,b)));}public:big_int():P("0"){}big_int(const string&s):P(D(s)){}big_int(const char*s):P(D(string(s))){}big_int(int x){P=to_string(x);}big_int(long long x){P=to_string(x);}string str()const{return P;}friend istream&operator>>(istream& i,big_int& n){string s;i>>s;n=big_int(s);return i;}friend ostream&operator<<(ostream&o,const big_int&n){o<<n.str();return o;}bool operator<(const big_int& n)const{bool a=C(P),b=C(n.P);if(a&&!b)return 1;if(!a&&b)return 0;string x=a?P.substr(1):P,y=b?n.P.substr(1):n.P;B(x,y);if(x.size()!=y.size())return (x.size()<y.size())^a;return x!=y?(x<y)^a:0;}bool operator>(const big_int& n)const{return n<*this;};bool operator==(const big_int& n)const{return P==n.P;}bool operator<=(const big_int& n)const{return P<n.P||P==n.P;}bool operator>=(const big_int& n)const{return P>n.P||P==n.P;}bool operator!=(const big_int& n)const{return!(P==n.P);}big_int operator+(const big_int& n)const{return big_int(H(this->P,n.P));}big_int operator-(const big_int& n)const{return big_int(G(this->P,n.P));}big_int operator*(const big_int& n)const{return big_int(K(this->P,n.P));}big_int operator/(const big_int& n)const{return big_int(M(this->P,n.P));}big_int operator%(const big_int& n)const{return big_int(N(this->P,n.P));}big_int operator+=(const big_int& n){this->P=D(H(this->P,n.P));return*this;}big_int operator-=(const big_int& n){this->P=D(G(this->P,n.P));return*this;}big_int operator*=(const big_int& n){this->P=D(K(this->P,n.P));return*this;}big_int operator/=(const big_int& n){this->P=D(M(this->P,n.P));return*this;}big_int&operator++(){*this+=big_int("1");return*this;}big_int operator++(int){big_int t=*this;++(*this);return t;}big_int&operator--(){*this-=big_int("1");return*this;}big_int operator--(int){big_int t=*this;--(*this);return t;}};int main(){return 0;}


*/
// class big_int{private:string P;static void A(string&s){int p=s.find_first_not_of(48);p==(int)string::npos?s="0":s.erase(0,p);}static void B(string&a,string&b){A(a);A(b);}static bool C(const string&s){return!s.empty()&&s[0]==45;}static string D(const string& s){if(s.empty()||s=="-0")return"0";bool n=s[0]==45;string t=n?s.substr(1):s;A(t);return t=="0"?"0":n?"-"+t:t;}static int E(string a,string b){B(a,b);if(a.size()>b.size())return 1;if(a.size()<b.size())return -1;if(a==b)return 0;return a>b?1:-1;}static string F(string a,string b){string r;int i=a.size()-1,j=b.size()-1,c=0;while(i+1||j+1||c){c+=(i+1?a[i--]-48:0)+(j+1?b[j--]-48:0);r+=c%10+48;c/=10;}reverse(r.begin(),r.end());return r;}static string G(const string&a,const string&b){bool n=C(a),m=C(b);if(n&&m)return G(b.substr(1),a.substr(1));if(n^m)return n?"-"+F(a.substr(1),b):F(a,b.substr(1));int c=E(a,b);if(!c)return"0";const string&x=c>0?a:b,&y=c>0?b:a;int i=x.size()-1,j=y.size()-1,k=0;string r;while(i>=0){int v=x[i--]-48-(j>=0?y[j--]-48:0)-k;k=v<0;if(v<0)v+=10;r+=v+48;}while(r.size()>1&&r.back()==48)r.pop_back();reverse(r.begin(),r.end());return c>0?r:"-"+r;}static string H(string a,string b){bool x=C(a),y=C(b);string A=x?a.substr(1):a,B=y?b.substr(1):b;if(!(x^y))return x?"-"+F(A,B):F(A,B);int c=E(A,B);return c?((c>0?(x?"-":"")+G(A,B):(y?"-":"")+G(B,A))):"0";}static void I(vector<complex<double>>&a){int n=a.size(),l=31-__builtin_clz(n);static vector<complex<long double>>r(2,1);static vector<complex<double>>t(2,1);for(static int k=2;k<n;k*=2){r.resize(n);t.resize(n);auto x=polar(1.0L,acos(-1.0L)/k);for(int i=k;i<k+k;i++)t[i]=r[i]=i&1?r[i/2]*x:r[i/2];}vector<int>v(n);for(int i=0;i<n;i++)v[i]=(v[i/2]|(i&1)<<l)/2;for(int i=0;i<n;i++)if(i<v[i])swap(a[i],a[v[i]]);for(int k=1;k<n;k*=2)for(int i=0;i<n;i+=2*k)for(int j=0;j<k;j++){auto x=(double*)&t[j+k],y=(double*)&a[i+j+k];complex<double>z(x[0]*y[0]-x[1]*y[1],x[0]*y[1]+x[1]*y[0]);a[i+j+k]=a[i+j]-z;a[i+j]+=z;}}template<typename T>static vector<T>J(const vector<T>&a, const vector<T>&b){if(a.empty()||b.empty())return {};vector<T>res((int)a.size()+(int)b.size()-1);int L=32-__builtin_clz((int)res.size()), n=1<<L;vector<complex<double>>in(n), out(n);copy(a.begin(),a.end(),begin(in));for(int i=0;i<(int)b.size();i++)in[i].imag(b[i]);I(in);for(complex<double>&x:in)x*=x;for(int i=0;i<n;i++)out[i]=in[-i&(n-1)]-conj(in[i]);I(out);for(int i=0;i<(int)res.size();i++)res[i]=static_cast<T>(imag(out[i])/(4*n)+((is_integral_v<T>)?(imag(out[i])>0?0.5:-0.5):0));return res;}static string K(const string&a,const string&b){int B=1000,D=3;bool n=C(a),m=C(b);string x=n?a.substr(1):a,y=m?b.substr(1):b;if(x=="0"||y=="0")return"0";vector<int>p,q;for(int i=x.size();i>0;i-=D){int t=0,l=max(0,i-D);for(int j=l;j<i;j++)t=t*10+x[j]-48;p.push_back(t);}for(int i=y.size();i>0;i-=D){int t=0,l=max(0,i-D);for(int j=l;j<i;j++)t=t*10+y[j]-48;q.push_back(t);}vector<long long>r=J(vector<long long>(p.begin(),p.end()),vector<long long>(q.begin(),q.end()));long long c=0;for(size_t i=0;i<r.size();i++){long long t=r[i]+c;r[i]=t%B;c=t/B;}while(c){r.push_back(c%B);c/=B;}while(r.size()>1&&r.back()==0)r.pop_back();string s=to_string(r.back());for(int i=r.size()-2;i>=0;i--){string t=to_string((int)r[i]);while(t.size()<D)t='0'+t;s+=t;}return n^m?"-"+s:s;}static string L(const string&a,const string&b,string q){return G(a,K(b,q));}static string M(const string& a,const string& b){string c=a,d=b;bool e=C(c),f=C(d);if(e)c=c.substr(1);if(f)d=d.substr(1);if(c=="0")return"0";if(d=="0")throw out_of_range("dividebyzeroerror");string g="",h="0";for(char k:c){h+=k;A(h);int i=0;while(1){string j=G(h,d);if(C(j))break;h=j;i++;}g+=i+48;}A(g);if(e^f)g="-"+g;if(DIVIDE_METHOD){if(C(L(a,b,g))){if(e^f)g=G(g,"1");else g=H(g,"1");}}else{if(L(a,b,g)=="0")return g=="-0"?"0":g;if(e^f)g=G(g,"1");}return g=="-0"?"0":g;}static string N(string a,string b){return G(a,K(b,M(a,b)));}public:big_int():P("0"){}big_int(const string&s):P(D(s)){}big_int(const char*s):P(D(string(s))){}big_int(int x){P=to_string(x);}big_int(long long x){P=to_string(x);}string str()const{return P;}friend istream&operator>>(istream& i,big_int& n){string s;i>>s;n=big_int(s);return i;}friend ostream&operator<<(ostream&o,const big_int&n){o<<n.str();return o;}bool operator<(const big_int& n)const{bool a=C(P),b=C(n.P);if(a&&!b)return 1;if(!a&&b)return 0;string x=a?P.substr(1):P,y=b?n.P.substr(1):n.P;B(x,y);if(x.size()!=y.size())return (x.size()<y.size())^a;return x!=y?(x<y)^a:0;}bool operator>(const big_int& n)const{return n<*this;};bool operator==(const big_int& n)const{return P==n.P;}bool operator<=(const big_int& n)const{return P<n.P||P==n.P;}bool operator>=(const big_int& n)const{return P>n.P||P==n.P;}bool operator!=(const big_int& n)const{return!(P==n.P);}big_int operator+(const big_int& n)const{return big_int(H(this->P,n.P));}big_int operator-(const big_int& n)const{return big_int(G(this->P,n.P));}big_int operator*(const big_int& n)const{return big_int(K(this->P,n.P));}big_int operator/(const big_int& n)const{return big_int(M(this->P,n.P));}big_int operator%(const big_int& n)const{return big_int(N(this->P,n.P));}big_int operator+=(const big_int& n){this->P=D(H(this->P,n.P));return*this;}big_int operator-=(const big_int& n){this->P=D(G(this->P,n.P));return*this;}big_int operator*=(const big_int& n){this->P=D(K(this->P,n.P));return*this;}big_int operator/=(const big_int& n){this->P=D(M(this->P,n.P));return*this;}big_int&operator++(){*this+=big_int("1");return*this;}big_int operator++(int){big_int t=*this;++(*this);return t;}big_int&operator--(){*this-=big_int("1");return*this;}big_int operator--(int){big_int t=*this;--(*this);return t;}};int main(){return 0;}
